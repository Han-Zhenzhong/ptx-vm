// Control flow PTX example for testing the virtual machine
// This program demonstrates branch instructions and loops

.version 6.0
.target sm_50
.address_size 64

// Define entry point function
.entry control_flow_kernel (
    .param .u64 input_ptr,
    .param .u64 result_ptr
)
{
    // Declare registers
    .reg .s32 %r<10>;
    .reg .pred %p<10>;
    
    // Load input parameters
    ld.param.u64 %r0, [input_ptr];
    ld.param.u64 %r1, [result_ptr];
    
    // Load input value from memory
    ld.global.s32 %r2, [%r0];  // r2 = input value
    mov.s32 %r3, 0;            // r3 = result (initialized to 0)
    mov.s32 %r4, 0;            // r4 = loop counter
    mov.s32 %r5, 5;            // r5 = loop limit
    
    // Read predicate register
    setp.eq.s32 %p0, %r4, 0;   // p0 = (r4 == 0)
    
    // Loop: sum numbers from 1 to 5
    // r3 = 0;
    // for (r4 = 0; r4 < 5; r4++) {
    //     r3 += r2;
    // }
    
loop_start:
    // Check loop condition
    setp.lt.s32 %p1, %r4, %r5;   // p1 = (r4 < r5)
    @%p1 bra loop_body;          // Branch if condition true
    bra loop_end;                // Branch unconditionally to end
    
loop_body:
    // Add input value to result
    add.s32 %r3, %r3, %r2;        // r3 += r2
    
    // Increment loop counter
    add.s32 %r4, %r4, 1;        // r4++
    
    // Branch back to start
    bra loop_start;
    
loop_end:
    // Store result to memory
    st.global.s32 [%r1], %r3;   // Store result
    
    // Exit kernel
    exit;
}