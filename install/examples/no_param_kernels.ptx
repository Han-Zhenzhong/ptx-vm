// PTX Example: Kernels without Parameters
// Demonstrates that PTX entry functions can have no parameters

.version 8.0
.target sm_80
.address_size 64

// Example 1: Simple kernel with no parameters
// Just prints thread ID to a fixed memory location
.visible .entry noParamKernel()
{
    .reg .u32 %r<5>;
    .reg .u64 %rd1;
    
    // Get thread ID
    mov.u32 %r1, %tid.x;
    
    // Store to fixed address 0x10000
    mov.u64 %rd1, 0x10000;
    st.global.u32 [%rd1], %r1;
    
    ret;
}

// Example 2: Kernel that uses special registers only
// Computes global thread ID and stores it
.visible .entry computeGlobalId()
{
    .reg .u32 %r<10>;
    .reg .u64 %rd<5>;
    
    // Get grid and block dimensions
    mov.u32 %r1, %ntid.x;     // blockDim.x
    mov.u32 %r2, %ctaid.x;    // blockIdx.x
    mov.u32 %r3, %tid.x;      // threadIdx.x
    
    // Compute global ID = blockIdx.x * blockDim.x + threadIdx.x
    mul.lo.u32 %r4, %r2, %r1;
    add.u32 %r5, %r4, %r3;
    
    // Store to fixed address 0x10000 + threadIdx.x * 4
    cvt.u64.u32 %rd1, %r3;
    shl.b64 %rd2, %rd1, 2;    // Multiply by 4
    mov.u64 %rd3, 0x10000;
    add.u64 %rd4, %rd3, %rd2;
    
    st.global.u32 [%rd4], %r5;
    
    ret;
}

// Example 3: Debug/test kernel
// Just returns immediately - useful for testing kernel launch
.visible .entry testKernel()
{
    ret;
}

// Example 4: Initialize fixed memory region
// Sets memory at 0x10000 to a pattern
.visible .entry initMemory()
{
    .reg .u32 %r<5>;
    .reg .u64 %rd<5>;
    .reg .pred %p1;
    
    // Get thread ID
    mov.u32 %r1, %tid.x;
    
    // Only process first 256 threads
    setp.ge.u32 %p1, %r1, 256;
    @%p1 bra END;
    
    // Calculate address: 0x10000 + tid * 4
    cvt.u64.u32 %rd1, %r1;
    shl.b64 %rd2, %rd1, 2;
    mov.u64 %rd3, 0x10000;
    add.u64 %rd4, %rd3, %rd2;
    
    // Store thread ID as value
    st.global.u32 [%rd4], %r1;
    
END:
    ret;
}

// Example 5: Atomic counter increment
// Increments a counter at fixed address 0x20000
.visible .entry atomicCounter()
{
    .reg .u32 %r<5>;
    .reg .u64 %rd1;
    
    // Address of counter
    mov.u64 %rd1, 0x20000;
    
    // Atomic increment
    atom.global.add.u32 %r1, [%rd1], 1;
    
    ret;
}

// Example 6: Barrier synchronization test
// All threads in a block synchronize
.visible .entry barrierTest()
{
    .reg .u32 %r1;
    .reg .u64 %rd1;
    
    // Get thread ID
    mov.u32 %r1, %tid.x;
    
    // Synchronize all threads
    bar.sync 0;
    
    // After barrier, store thread ID
    mov.u64 %rd1, 0x10000;
    st.global.u32 [%rd1], %r1;
    
    ret;
}

// Example 7: Kernel that uses shared memory (no parameters needed)
.visible .entry sharedMemTest()
{
    .reg .u32 %r<5>;
    .reg .u64 %rd1;
    .shared .align 4 .b8 shared_data[1024];
    
    // Get thread ID
    mov.u32 %r1, %tid.x;
    
    // Write to shared memory
    cvt.u64.u32 %rd1, %r1;
    shl.b64 %rd1, %rd1, 2;
    st.shared.u32 [shared_data + %rd1], %r1;
    
    // Synchronize
    bar.sync 0;
    
    // Read from shared memory
    ld.shared.u32 %r2, [shared_data + %rd1];
    
    ret;
}

// Example 8: Print "Hello World" (if printf is supported)
// Note: This is a simplified version
.visible .entry helloWorld()
{
    .reg .u32 %r1;
    
    // Get thread 0
    mov.u32 %r1, %tid.x;
    
    // In a real implementation with printf support,
    // thread 0 would print "Hello World"
    // For now, just return
    
    ret;
}
