//
// PTX VM - Comprehensive Test Suite
// Tests all new features implemented in sections 1-9
//

.version 7.0
.target sm_50
.address_size 64

//
// Test 1: Parameter Passing (Section 1)
// Verifies that ld.param correctly reads kernel parameters
//
.entry test_parameter_passing(
    .param .u64 output_ptr,
    .param .s32 value_a,
    .param .s32 value_b
)
{
    .reg .s32 %r<5>;
    .reg .u64 %rd1;
    
    // Load parameters
    ld.param.u64 %rd1, [output_ptr];
    ld.param.s32 %r1, [value_a];
    ld.param.s32 %r2, [value_b];
    
    // Compute sum
    add.s32 %r3, %r1, %r2;
    
    // Store result
    st.global.s32 [%rd1], %r3;
    
    exit;
}

//
// Test 2: Float Register Operations (Section 2)
// Tests floating-point register read/write
//
.entry test_float_registers(
    .param .u64 result_ptr
)
{
    .reg .f32 %f<10>;
    .reg .u64 %rd1;
    
    ld.param.u64 %rd1, [result_ptr];
    
    // Write to float registers
    mov.f32 %f1, 1.5;
    mov.f32 %f2, 2.5;
    mov.f32 %f3, 3.5;
    
    // Read and write operations
    add.f32 %f4, %f1, %f2;  // 4.0
    mul.f32 %f5, %f2, %f3;  // 8.75
    
    // Store results
    st.global.f32 [%rd1], %f4;
    st.global.f32 [%rd1+4], %f5;
    
    exit;
}

//
// Test 3: Special Registers (Section 3)
// Verifies thread ID, block ID, and dimensions
//
.entry test_special_registers(
    .param .u64 output_ptr
)
{
    .reg .u32 %r<10>;
    .reg .u64 %rd1;
    
    ld.param.u64 %rd1, [output_ptr];
    
    // Read special registers
    mov.u32 %r1, %tid.x;
    mov.u32 %r2, %tid.y;
    mov.u32 %r3, %tid.z;
    mov.u32 %r4, %ctaid.x;
    mov.u32 %r5, %ntid.x;
    mov.u32 %r6, %nctaid.x;
    mov.u32 %r7, %warpsize;
    mov.u32 %r8, %laneid;
    
    // Store all values
    st.global.u32 [%rd1], %r1;
    st.global.u32 [%rd1+4], %r2;
    st.global.u32 [%rd1+8], %r3;
    st.global.u32 [%rd1+12], %r4;
    st.global.u32 [%rd1+16], %r5;
    st.global.u32 [%rd1+20], %r6;
    st.global.u32 [%rd1+24], %r7;
    st.global.u32 [%rd1+28], %r8;
    
    exit;
}

//
// Test 4: Floating-Point Instructions (Section 5)
// Tests add, sub, mul, div, fma, sqrt, neg, abs
//
.entry test_float_instructions(
    .param .u64 result_ptr
)
{
    .reg .f32 %f<15>;
    .reg .u64 %rd1;
    
    ld.param.u64 %rd1, [result_ptr];
    
    // Basic arithmetic
    mov.f32 %f1, 10.0;
    mov.f32 %f2, 3.0;
    
    add.f32 %f3, %f1, %f2;  // 13.0
    sub.f32 %f4, %f1, %f2;  // 7.0
    mul.f32 %f5, %f1, %f2;  // 30.0
    div.f32 %f6, %f1, %f2;  // 3.333...
    
    // FMA: fma(a, b, c) = a * b + c
    mov.f32 %f7, 2.0;
    mov.f32 %f8, 5.0;
    mov.f32 %f9, 1.0;
    fma.f32 %f10, %f7, %f8, %f9;  // 2*5+1 = 11.0
    
    // Square root
    mov.f32 %f11, 16.0;
    sqrt.f32 %f12, %f11;  // 4.0
    
    // Negation and absolute value
    mov.f32 %f13, -5.5;
    neg.f32 %f14, %f13;   // 5.5
    abs.f32 %f15, %f13;   // 5.5
    
    // Store results
    st.global.f32 [%rd1], %f3;      // 0: add
    st.global.f32 [%rd1+4], %f4;    // 4: sub
    st.global.f32 [%rd1+8], %f5;    // 8: mul
    st.global.f32 [%rd1+12], %f6;   // 12: div
    st.global.f32 [%rd1+16], %f10;  // 16: fma
    st.global.f32 [%rd1+20], %f12;  // 20: sqrt
    st.global.f32 [%rd1+24], %f14;  // 24: neg
    st.global.f32 [%rd1+28], %f15;  // 28: abs
    
    exit;
}

//
// Test 5: SETP Comparison (Section 6)
// Tests all comparison operators
//
.entry test_setp_comparisons(
    .param .u64 result_ptr
)
{
    .reg .s32 %r<10>;
    .reg .f32 %f<5>;
    .reg .pred %p<8>;
    .reg .u64 %rd1;
    
    ld.param.u64 %rd1, [result_ptr];
    
    // Integer comparisons
    mov.s32 %r1, 10;
    mov.s32 %r2, 20;
    
    setp.lt.s32 %p1, %r1, %r2;  // true (10 < 20)
    setp.le.s32 %p2, %r1, %r2;  // true (10 <= 20)
    setp.gt.s32 %p3, %r1, %r2;  // false (10 > 20)
    setp.ge.s32 %p4, %r1, %r2;  // false (10 >= 20)
    setp.eq.s32 %p5, %r1, %r2;  // false (10 == 20)
    setp.ne.s32 %p6, %r1, %r2;  // true (10 != 20)
    
    // Convert predicates to integers for output
    selp.s32 %r3, 1, 0, %p1;
    selp.s32 %r4, 1, 0, %p2;
    selp.s32 %r5, 1, 0, %p3;
    selp.s32 %r6, 1, 0, %p4;
    selp.s32 %r7, 1, 0, %p5;
    selp.s32 %r8, 1, 0, %p6;
    
    // Floating-point comparison
    mov.f32 %f1, 3.14;
    mov.f32 %f2, 2.71;
    setp.gt.f32 %p7, %f1, %f2;  // true (3.14 > 2.71)
    selp.s32 %r9, 1, 0, %p7;
    
    // Store results
    st.global.s32 [%rd1], %r3;      // 0: lt
    st.global.s32 [%rd1+4], %r4;    // 4: le
    st.global.s32 [%rd1+8], %r5;    // 8: gt
    st.global.s32 [%rd1+12], %r6;   // 12: ge
    st.global.s32 [%rd1+16], %r7;   // 16: eq
    st.global.s32 [%rd1+20], %r8;   // 20: ne
    st.global.s32 [%rd1+24], %r9;   // 24: float gt
    
    exit;
}

//
// Test 6: SELP Conditional Selection (Section 7)
// Tests predicate-based selection
//
.entry test_selp_selection(
    .param .u64 result_ptr
)
{
    .reg .s32 %r<10>;
    .reg .f32 %f<10>;
    .reg .pred %p<3>;
    .reg .u64 %rd1;
    
    ld.param.u64 %rd1, [result_ptr];
    
    // Integer SELP
    mov.s32 %r1, 100;
    mov.s32 %r2, 200;
    mov.u32 %r3, 1;  // true predicate
    mov.u32 %r4, 0;  // false predicate
    
    // Note: Need to convert to predicates first
    setp.ne.s32 %p1, %r3, 0;  // true
    setp.ne.s32 %p2, %r4, 0;  // false
    
    selp.s32 %r5, %r1, %r2, %p1;  // Select %r1 (100)
    selp.s32 %r6, %r1, %r2, %p2;  // Select %r2 (200)
    
    // Float SELP
    mov.f32 %f1, 3.14;
    mov.f32 %f2, 2.71;
    selp.f32 %f3, %f1, %f2, %p1;  // Select %f1 (3.14)
    selp.f32 %f4, %f1, %f2, %p2;  // Select %f2 (2.71)
    
    // Store results
    st.global.s32 [%rd1], %r5;
    st.global.s32 [%rd1+4], %r6;
    st.global.f32 [%rd1+8], %f3;
    st.global.f32 [%rd1+12], %f4;
    
    exit;
}

//
// Test 7: CVT Type Conversion (Section 8)
// Tests all major type conversions
//
.entry test_cvt_conversions(
    .param .u64 result_ptr
)
{
    .reg .f32 %f<10>;
    .reg .s32 %r<10>;
    .reg .u32 %u<10>;
    .reg .u64 %rd1;
    
    ld.param.u64 %rd1, [result_ptr];
    
    // Float to signed int
    mov.f32 %f1, 3.14;
    cvt.s32.f32 %r1, %f1;  // 3
    
    mov.f32 %f2, -2.71;
    cvt.s32.f32 %r2, %f2;  // -2
    
    // Float to unsigned int
    mov.f32 %f3, 5.99;
    cvt.u32.f32 %u1, %f3;  // 5
    
    // Signed int to float
    mov.s32 %r3, 42;
    cvt.f32.s32 %f4, %r3;  // 42.0
    
    mov.s32 %r4, -100;
    cvt.f32.s32 %f5, %r4;  // -100.0
    
    // Unsigned int to float
    mov.u32 %u2, 1000;
    cvt.f32.u32 %f6, %u2;  // 1000.0
    
    // Store results
    st.global.s32 [%rd1], %r1;      // 0: f32->s32 (3)
    st.global.s32 [%rd1+4], %r2;    // 4: f32->s32 (-2)
    st.global.u32 [%rd1+8], %u1;    // 8: f32->u32 (5)
    st.global.f32 [%rd1+12], %f4;   // 12: s32->f32 (42.0)
    st.global.f32 [%rd1+16], %f5;   // 16: s32->f32 (-100.0)
    st.global.f32 [%rd1+20], %f6;   // 20: u32->f32 (1000.0)
    
    exit;
}

//
// Test 8: Atomic Operations (Section 9)
// Tests atomic add, sub, exch, cas, min, max
//
.entry test_atomic_operations(
    .param .u64 counter_ptr
)
{
    .reg .u32 %r<10>;
    .reg .u64 %rd1;
    
    ld.param.u64 %rd1, [counter_ptr];
    
    // Test ATOM.ADD
    mov.u32 %r1, 5;
    atom.global.add.u32 %r2, [%rd1], %r1;  // Add 5, return old value
    
    // Test ATOM.SUB (at offset 4)
    mov.u32 %r3, 3;
    atom.global.sub.u32 %r4, [%rd1+4], %r3;  // Subtract 3
    
    // Test ATOM.EXCH (at offset 8)
    mov.u32 %r5, 999;
    atom.global.exch.u32 %r6, [%rd1+8], %r5;  // Exchange with 999
    
    // Test ATOM.CAS (at offset 12)
    mov.u32 %r7, 100;  // Compare value
    mov.u32 %r8, 200;  // New value
    atom.global.cas.u32 %r9, [%rd1+12], %r7, %r8;  // CAS
    
    // Store old values for verification
    st.global.u32 [%rd1+16], %r2;  // Old value from ADD
    st.global.u32 [%rd1+20], %r4;  // Old value from SUB
    st.global.u32 [%rd1+24], %r6;  // Old value from EXCH
    st.global.u32 [%rd1+28], %r9;  // Old value from CAS
    
    exit;
}

//
// Test 9: Combined Features
// Uses multiple features together
//
.entry test_combined_features(
    .param .u64 data_ptr,
    .param .f32 threshold,
    .param .s32 count
)
{
    .reg .f32 %f<10>;
    .reg .s32 %r<10>;
    .reg .pred %p<3>;
    .reg .u64 %rd1;
    .reg .u32 %tid;
    
    ld.param.u64 %rd1, [data_ptr];
    ld.param.f32 %f1, [threshold];
    ld.param.s32 %r1, [count];
    
    // Get thread ID
    mov.u32 %tid, %tid.x;
    cvt.s32.u32 %r2, %tid;
    
    // Load data based on thread ID
    mul.s32 %r3, %r2, 4;  // offset = tid * 4
    cvt.u64.s32 %rd2, %r3;
    add.u64 %rd3, %rd1, %rd2;
    ld.global.f32 %f2, [%rd3];
    
    // Compare with threshold
    setp.ge.f32 %p1, %f2, %f1;
    
    // Conditional computation
    mov.f32 %f3, 2.0;
    mov.f32 %f4, 0.5;
    selp.f32 %f5, %f3, %f4, %p1;  // Multiply by 2.0 or 0.5
    
    mul.f32 %f6, %f2, %f5;
    
    // Convert result to integer
    cvt.s32.f32 %r4, %f6;
    
    // Atomic increment of counter
    mov.u32 %r5, 1;
    setp.ne.s32 %p2, %r4, 0;
    @%p2 atom.global.add.u32 %r6, [%rd1+1024], %r5;
    
    // Store result
    st.global.f32 [%rd3], %f6;
    st.global.s32 [%rd3+4], %r4;
    
    exit;
}

//
// Test 10: Min/Max Atomic Operations
//
.entry test_atomic_min_max(
    .param .u64 data_ptr
)
{
    .reg .u32 %r<10>;
    .reg .u64 %rd1;
    
    ld.param.u64 %rd1, [data_ptr];
    
    // Test ATOM.MIN
    mov.u32 %r1, 50;
    atom.global.min.u32 %r2, [%rd1], %r1;  // min(old, 50)
    
    // Test ATOM.MAX
    mov.u32 %r3, 100;
    atom.global.max.u32 %r4, [%rd1+4], %r3;  // max(old, 100)
    
    // Store old values
    st.global.u32 [%rd1+8], %r2;
    st.global.u32 [%rd1+12], %r4;
    
    exit;
}

//
// Expected Test Results:
//
// Test 1 (Parameter Passing):
//   - output[0] = value_a + value_b
//
// Test 2 (Float Registers):
//   - output[0] = 4.0
//   - output[1] = 8.75
//
// Test 3 (Special Registers):
//   - output[0-7] = tid.x, tid.y, tid.z, ctaid.x, ntid.x, nctaid.x, warpsize, laneid
//
// Test 4 (Float Instructions):
//   - output[0] = 13.0 (add)
//   - output[1] = 7.0 (sub)
//   - output[2] = 30.0 (mul)
//   - output[3] = 3.333... (div)
//   - output[4] = 11.0 (fma)
//   - output[5] = 4.0 (sqrt)
//   - output[6] = 5.5 (neg)
//   - output[7] = 5.5 (abs)
//
// Test 5 (SETP):
//   - output[0] = 1 (lt: true)
//   - output[1] = 1 (le: true)
//   - output[2] = 0 (gt: false)
//   - output[3] = 0 (ge: false)
//   - output[4] = 0 (eq: false)
//   - output[5] = 1 (ne: true)
//   - output[6] = 1 (float gt: true)
//
// Test 6 (SELP):
//   - output[0] = 100 (true: select first)
//   - output[1] = 200 (false: select second)
//   - output[2] = 3.14 (true: select first)
//   - output[3] = 2.71 (false: select second)
//
// Test 7 (CVT):
//   - output[0] = 3 (f32->s32)
//   - output[1] = -2 (f32->s32)
//   - output[2] = 5 (f32->u32)
//   - output[3] = 42.0 (s32->f32)
//   - output[4] = -100.0 (s32->f32)
//   - output[5] = 1000.0 (u32->f32)
//
// Test 8 (Atomic Ops):
//   - counter[0] += 5
//   - counter[1] -= 3
//   - counter[2] = 999
//   - counter[3] = 200 if old was 100
//   - output[4-7] = old values
//
