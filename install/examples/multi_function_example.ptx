// PTX example with multiple functions
// Demonstrates device functions (.func) and kernel entry points (.entry)

.version 6.0
.target sm_50
.address_size 64

// Device function 1: Add two numbers
.func (.reg .s32 %result) add_numbers (
    .param .s32 %a,
    .param .s32 %b
)
{
    .reg .s32 %r<4>;
    
    ld.param.s32 %r1, [%a];
    ld.param.s32 %r2, [%b];
    add.s32 %r3, %r1, %r2;
    st.param.s32 [%result], %r3;
    ret;
}

// Device function 2: Multiply two numbers
.func (.reg .s32 %product) multiply_numbers (
    .param .s32 %x,
    .param .s32 %y
)
{
    .reg .s32 %r<4>;
    
    ld.param.s32 %r1, [%x];
    ld.param.s32 %r2, [%y];
    mul.s32 %r3, %r1, %r2;
    st.param.s32 [%product], %r3;
    ret;
}

// Device function 3: Compute (a + b) * c
.func (.reg .s32 %out) compute_expression (
    .param .s32 %a,
    .param .s32 %b,
    .param .s32 %c
)
{
    .reg .s32 %r<8>;
    .reg .s32 %sum;
    
    // Call add_numbers(a, b)
    {
        .param .s32 param0;
        .param .s32 param1;
        .param .s32 retval;
        
        ld.param.s32 %r1, [%a];
        ld.param.s32 %r2, [%b];
        st.param.s32 [param0], %r1;
        st.param.s32 [param1], %r2;
        call (%sum), add_numbers, (param0, param1);
    }
    
    // Call multiply_numbers(sum, c)
    {
        .param .s32 param0;
        .param .s32 param1;
        .param .s32 retval;
        
        ld.param.s32 %r3, [%c];
        st.param.s32 [param0], %sum;
        st.param.s32 [param1], %r3;
        call (%out), multiply_numbers, (param0, param1);
    }
    
    ret;
}

// Kernel entry point 1: Process array
.entry kernel_process_array (
    .param .u64 input_ptr,
    .param .u64 output_ptr,
    .param .u32 size
)
{
    .reg .s32 %r<20>;
    .reg .u64 %rd<10>;
    .reg .pred %p<5>;
    
    // Load parameters
    ld.param.u64 %rd1, [input_ptr];
    ld.param.u64 %rd2, [output_ptr];
    ld.param.u32 %r1, [size];
    
    // Process first element using device function
    ld.global.s32 %r2, [%rd1];
    ld.global.s32 %r3, [%rd1+4];
    
    {
        .param .s32 param_a;
        .param .s32 param_b;
        .param .s32 param_c;
        .param .s32 result;
        
        st.param.s32 [param_a], %r2;
        st.param.s32 [param_b], %r3;
        mov.s32 %r4, 2;
        st.param.s32 [param_c], %r4;
        
        call (result), compute_expression, (param_a, param_b, param_c);
        
        ld.param.s32 %r5, [result];
        st.global.s32 [%rd2], %r5;
    }
    
    exit;
}

// Kernel entry point 2: Simple test kernel
.entry kernel_simple_test (
    .param .u64 data_ptr
)
{
    .reg .s32 %r<5>;
    .reg .u64 %rd<3>;
    
    ld.param.u64 %rd1, [data_ptr];
    
    mov.s32 %r1, 10;
    mov.s32 %r2, 20;
    
    {
        .param .s32 a;
        .param .s32 b;
        .param .s32 sum;
        
        st.param.s32 [a], %r1;
        st.param.s32 [b], %r2;
        call (sum), add_numbers, (a, b);
        
        ld.param.s32 %r3, [sum];
        st.global.s32 [%rd1], %r3;
    }
    
    exit;
}
