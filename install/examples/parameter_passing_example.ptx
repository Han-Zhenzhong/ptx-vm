// PTX example demonstrating parameter passing
// This program shows how to work with kernel parameters in PTX VM

.version 6.0
.target sm_50
.address_size 64

// Define entry point function with parameters
.entry parameter_passing_kernel (
    .param .u64 input_ptr,
    .param .u64 output_ptr,
    .param .u32 data_size
)
{
    // Declare registers
    .reg .s32 %r<20>;
    .reg .f32 %f<10>;
    .reg .pred %p<5>;
    
    // Load input parameters
    ld.param.u64 %r1, [input_ptr];
    ld.param.u64 %r2, [output_ptr];
    ld.param.u32 %r3, [data_size];
    
    // Initialize loop variables
    mov.s32 %r4, 0;              // Loop counter (i = 0)
    mov.s32 %r5, %r3;            // Loop limit (size)
    
    // Process data in a loop
    // for (int i = 0; i < size; i++) {
    //     output[i] = input[i] * 2.0f;
    // }
    
loop_start:
    // Check loop condition (i < size)
    setp.lt.s32 %p1, %r4, %r5;
    @%p1 bra loop_body;
    bra loop_end;
    
loop_body:
    // Calculate memory addresses
    // address = base + index * element_size
    mul.lo.s32 %r6, %r4, 4;      // r6 = i * 4 (element offset)
    add.s32 %r7, %r1, %r6;       // r7 = input_ptr + offset
    add.s32 %r8, %r2, %r6;       // r8 = output_ptr + offset
    
    // Load input value
    ld.global.s32 %r9, [%r7];    // r9 = input[i]
    
    // Perform computation (multiply by 2)
    shl.b32 %r10, %r9, 1;        // r10 = r9 << 1 (equivalent to r9 * 2)
    
    // Store result
    st.global.s32 [%r8], %r10;   // output[i] = input[i] * 2
    
    // Increment loop counter
    add.s32 %r4, %r4, 1;         // i++
    
    // Branch back to loop start
    bra loop_start;
    
loop_end:
    // Exit kernel
    exit;
}